\section{Type checking}

\todo{Assigned Liam}

Programmers inevitably make mistakes. No person can be vigilant towards every possible slip-up all the time. While there are many tasks computers excel at, understanding the programmer’s intent and detecting differences between it and the behaviour of the programs they write (i.e. bugs) is not one of them. To aid in the automatic detection of bugs, so called type systems have been devised.

Type systems are rules governing what is and is not a valid program; they group values in the programming language into types, and specify rules about what is or is not a valid interaction between them. For example, in most if not all languages it is not acceptable to apply a number to a value as if it were a function. The difference between dynamically and statically typed programming languages is whether the erroneous application is discovered at run time or compile time.

Type systems automatically detect nonsensical code at compile time – (such as the program treating a Boolean as a list of Booleans) which reveals many bugs shortly after they are written, allowing the programmer to diagnose bugs when the code they’ve written is fresh in their mind. Types also allow programmers to communicate properties of their program to others in a concise way. For example: in Haskell a program which has some arbitrary interaction with the outside world and returns a Boolean to the caller when it’s done can be distinguished by its type (IO Bool) from one which simply calculates the truth value of a pure mathematical proposition (which would be of type Bool).

Hopper uses a type system similar to Haskell's to provide compile-time guarantees about program behaviour on Erlang's BEAM virtual machine. BEAM is focused on supporting concurrent processes and message passing of dynamically typed data between them (a side effect-rich environment with ample opportunities for type errors). In section 4.5, we will demonstrate the advantages of using types to describe concurrent programs.
