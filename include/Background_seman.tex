\section{Semantic analysis}

An important design decision to make when implementing a programming language is wether to perform some semantic analyses of the code at compile time and what to include in such case. Semantic analyses can for example contribute error detection and optimized code. The cost is increased complexity of the compiler and for some kinds of analysis prohibitive compilation times.

A common and well studied category of analyses is type inference or type checking. Type systems vary in their expressiveness but essentially allow us to prove desireable properties of our code.

\todo{Motivation of Hopper is to bring type checking to erlang}

\todo{What we want from the type system}

\subsection{Type inference}

\todo{Choice of type system}

\todo{Constraint generation by means of inference rules}

\todo{Constraint solving}

\todo{Reporting type results}

%------------------

%what
%  in general
%    a step in the compilation process
%    examine details of the code which cannot be captured be the grammar itself.
%    example control flow analysis
%  type inference
%    a formal system
%    system F in Haskell
%    we use Hindley-Milner type system to begin with

%why
%  in general
%    prove properties
%    show correctness/show absence of errors
%  type inference
%    tractable
%    well established

%how
%  preprocess
%    the simple language
%      lambda calc
%        expressiveness etc
%        extensions (let, fix)
%    transformations
%      parse -> AST ?
%      AST -> simple language
%      important: keep semantics
%  type inference
%    generating constraints by inference rules
%    solving constraints by solving rules
%  postprocess
%    looking upp the solved types and reporting them
