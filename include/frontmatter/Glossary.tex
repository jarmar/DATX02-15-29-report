% Uses glossary package

% A new entry:
%
% \newglossaryentry{<label>}
% { name={<theword>},
%   description={<Explaning text>}
% }


% A new acronym
%
% \newacronym{<label>}{<abbrv>}{<full>}

%\todo{Assigned to everyone}
%\todo{Screen useful entries}

\newacronym{ast}{AST}{Abstract Syntax Tree}
\newacronym{adt}{ADT}{algebraic data type}
\newacronym{bif}{BIF}{built in function}
\newacronym{bnf}{BNF}{Backus-Naur form}
\newacronym{dag}{DAG}{directed acyclic graph}

% Type inference category

\newglossaryentry{algow}
{ name={algorithm W},
  description={Algorithm W is an algorithm which infer the type of expressions in the Hindley-Milner type system}
}

\longnewglossaryentry{boundvar}
{ name={bound variable} }
{A variable bound in a context. Opposite of free variable. A type variable can be quantified over in a type and thus bound.

Example $\forall a . a \to a$ has the type variable a bound by the universal quantifier.}

\longnewglossaryentry{bnfc}{ name={BNF Converter}}{A program developed at Chalmers for converting BNF grammar to a lexer and parser. See reference \cite{bnfc}}

\newglossaryentry{completeness}
{ name={completeness},
  description={A property of formal systems. A system is complete if all its formulas can be infered in the system.
(look up reference, FOL?)}
}

\newglossaryentry{constraint}
{ name={constraint},
  description={A constraint is an equality statement between two types. The constraint $Int \to Bool = a \to b$ will, as an example, be resolved into the constraints $a = Int$ and $b = Bool$}
}

\newglossaryentry{context}
{ name={context},
  description={See environment}
}

\newglossaryentry{damas}
{ name={Damas},
  description={Luis Damas. Proved the soundness and completeness of Algorithm W}
} %  REF: (http://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf)}

\newglossaryentry{environment}
{ name={environment},
  description={The association between term variables and types. The typing in the environment gives meaning to the variables. The environment can be extended and reduced to give local name space}
}

\newglossaryentry{freevar}
{ name={free variable},
  description={A variable not bound by a quantifier. Opposite of bound variable}
}

\newglossaryentry{freshvar}
{ name={fresh variable},
  description={A new variable with a name that is not used anywhere else in the context}
}

\newglossaryentry{generalization}
{ name={generalization},
  description={Generalization, in the context of polymorphic type inference, is the binding of free type variables in a type. $\forall a . a \to a$ is the generalized version of $a \to a$}
}

\newglossaryentry{generator}
{ name={constraint generation},
  description={The constraint generator traverse an expression and infer constraints on every part of the expression using the inference rules of the type system The constraints are collected and this equation system of constraints are later solved by the constraint solver}
}

\newglossaryentry{hindley}
{ name={Hindley},
  description={J. Roger Hindley (1938-). British Logician. First described the the type system for lambda calculus with parametric polymorphism}
} % REF: (http://en.wikipedia.org/wiki/J._Roger_Hindley)}

\newglossaryentry{hmtypesystem}
{ name={Hindley-Milner type system},
  description={A type system for the lambda calculus with parametric polymorphism. Also known as Damas-Hindley-Milner}
}

\newglossaryentry{inference}
{ name={inference},
  description={The process of finding a type of an expression}
}

\newglossaryentry{inferencerule}
{ name={inference rule},
  description={Rule which state what conclusion we may draw from what premises. See appendix for a listing of the inference rules used in the type inferencer}
}

\newglossaryentry{infinitetype}
{ name={infinite type},
  description={An infinite type occurs when a type variable is constrained in terms of itself. In other words the type variable occurs on both sides of the equals sign, for example $A = A \to A$}
}

\newglossaryentry{instantiation}
{ name={instantiation},
  description={Instantiation, in the context of polymorphic type inference, allow an expression to have different types in different contexts by substituting all bound variable names with fresh ones. $\forall b . b \to b$ is an instantiated version of $\forall a . a \to a$}
}

\newglossaryentry{intractable}
{ name={intractable},
  description={See tractable}
}

\newglossaryentry{judgement}
{ name={judgement},
  description={See inference rule}
}

\newglossaryentry{lambdacalc}
{ name={lambda calculus},
  description={A mathematical system and model of computation, by function abstraction and application of variables, formulated by Alonzo Church. Church-Turing complete.}
} % Maybe list the constructs of lc

\newglossaryentry{milner}
{ name={Milner},
  description={Robin Milner (1934-2010). British Computer Scientist. Developed ML (meta language), the first language with polymorphic type inference and type-safe exception handling.}
} % REF: (http://en.wikipedia.org/wiki/Robin\_Milner) (maybe better reference material in TaPL)}

\newglossaryentry{monomorph}
{ name={monomorphism},
  description={Something that has a sole behavior/form. See polymorphism}
}

\longnewglossaryentry{mgu}
{ name={most general unifier} }
{A property of the Hindley-Milner type system is that if there is a unifier between two types, then there is an unique (barring name changes) most general unifier for the same two types. In other words there exist a unique unifier which make the least amount of assumptions about the types.

Take for example the two types $a \to Bool$ and $b \to Bool$. One unifier would be
$[a/Int][b/Int]$ but this would not be a most general unifier. The most general unifier would be $[a/b]$ (or $[b/a]$ but the only difference in the result is the names, which we disregard)}

\longnewglossaryentry{mutrec}
{ name={mutual recursion} }
{Two or more objects defined in terms of each other.

Example
\begin{align*}
f(0) &= 0 \\
f(n) &= g(n-1) \\
g(0) &= 1 \\
g(n) &= f(n-1)
\end{align*}
}

\newglossaryentry{normalization}
{ name={normalization},
  description={Normalization, in the context of polymorphic type inference, is a cosmetic operation where bound type variable names are replaced with more readable names. For example $('a2 \to 'a12) \to 'a2$ is normalized to $(a \to b) \to a$}
}

\newglossaryentry{occurs}
{ name={occurs check},
  description={Occurs checks are performed during constraint solving to identify infinite types}
}

\newglossaryentry{polymorph}
{ name={polymorphism},
  description={parametric polymorphism: a function or type declared with generic parameters that handles them identically. Ex. the identity function id has type $\forall a . a \to a$}
}

\newglossaryentry{reconstruction}
{ name={reconstruction},
  description={See inference}
}

\newglossaryentry{recursion}
{ name={recursion},
  description={Calling or referencing oneself. For example a recursive function returning the $sum$ from $1$ to $n$: $sum(0) = 0, sum(n) = n + sum(n-1)$.
See recursion}
}

\newglossaryentry{scheme}
{ name={scheme},
  description={A scheme is a type along with a set of the variable names in the type which are bound by a forall quantifier. A scheme can be instantiated}
}

\newglossaryentry{seman}
{ name={semantic analysis},
  description={In the context of compiler construction semantic analysis is performed after lexing and parsing and checks for errors which can't be captured by the grammar of the language. For example that variables are defined before their use. Type checking is one kind of semantic analysis}
}

\newglossaryentry{semantics}
{ name={semantics},
  description={The meaning of formulas. Often expressed in natural language}
}

\newglossaryentry{solver}
{ name={constraint solving},
  description={For a type signature consisting of unique fresh type variables the solver solves a set of constraints to find the most general type}
}

\newglossaryentry{soundness}
{ name={soundness},
  description={A property of formal systems. A system is sound if the inference rules only produce valid conclusions from valid premisses}
} % (look up reference, FOL?)}

\newglossaryentry{subst}
{ name={substitution},
  description={A mapping from type variables $v_1...v_n$ to types $t_1...t_n$, written as $[v_1/t_1,v_2/t_2,...,v_n/t_n]$, representing a substitution of each $v_i$ to $t_i$. Applying a substitution to a type $A$ substitutes the type variables in $A$. The empty substitution [] does not change the type (no type variables are substituted)}
}

\newglossaryentry{syntax}
{ name={syntax},
  description={The structure or form of a formulas. Often given by recursive definitions as grammars}
}

\newglossaryentry{systemf}
{ name={system F},
  description={A typed lambda calculus with universal quantification over types}
}

\newglossaryentry{toplevel}
{ name={top level definition},
  description={Expression that appear globally in a module and can be referred to by any other definition in the module}
}

\newglossaryentry{topsort}
{ name={topological sorting},
  description={A topological sort of a directed graph is an ordering of its vertices such that for each edge $uv$ from vertex $u$ to vertex $v$, $u$ comes before $v$}
}

\newglossaryentry{tractable}
{ name={tractable},
  description={A problem in complexity class P meaning that it can be computed in polynomial time in relation to the input size}
}

\newglossaryentry{typechecking}
{ name={type checking},
  description={See inference}
}

\longnewglossaryentry{typesystem}
{ name={type system} }
{A type system is a formal system wherein types of expressions can be infered. Infering a type amount to proving the type using the inference rules of the formal system.

Type systems are used to prove certain tractable properties of the code. For example that arithmetic operators are only applied to numeric values. Properties like termination and total function definitions are often left out of type systems since those problems are undecidable (intractable).

See also system F and Hindley-Milner type system.
}

\newglossaryentry{typevar}
{ name={type variable},
  description={A variable representing some type. See free/bound variable}
}

\longnewglossaryentry{unification}
{ name={unification} }
{Two types $A$, $B$ are unifiable if there exists a substitution $S$, from type variables to types, such that $S(A) = S(B)$.

For example unifying a type (variable) $a$ with the type $Int$ would yield a substitution $S = [a/Int]$ since $S(a) = [a/Int]a = Int = [a/Int]Int = S(Int)$.
}

\newglossaryentry{unifier}
{ name={unifier},
  description={A unifier is a substitution $S$ for types $A$ and $B$ which satisfy the criteria $S(A) = S(B)$}
}


