% Uses glossary package

% A new entry:
%
% \newglossaryentry{<label>}
% { name={<theword>},
%   description={<Explaning text>}
% }


% A new acronym
%
% \newacronym{<label>}{<abbrv>}{<full>}

%\todo{Assigned to everyone}
%\todo{Screen useful entries}

\newacronym{ast}{AST}{abstract syntax tree}
\newacronym{adt}{ADT}{algebraic data type}
\newacronym{bif}{BIF}{built in function}
\newacronym{bnf}{BNF}{Backus-Naur form}
\newacronym{dag}{DAG}{directed acyclic graph}
\newacronym{scc}{SCC}{strongly connected component}

% Type inference category

\newglossaryentry{arity}
{ name={arity},
  description={The arity of a function is the number of arguments it accepts},
  plural={arities}
}

\newglossaryentry{algow}
{ name={algorithm W},
  description={Algorithm W is an algorithm which infers the types of expressions in the Hindley-Milner type system}
}

\newglossaryentry{beam}
{ name={BEAM},
  description={Erlang's Virtual Machine}
}

\longnewglossaryentry{bnfc}{ name={BNF Converter}}{A program developed at Chalmers for converting BNF grammar to a lexer and parser. See reference \cite{bnfc}}

\newglossaryentry{constraint}
{ name={constraint},
  description={A constraint is an equality statement between two types. The constraint $Int \to Bool = a \to b$ will, as an example, be resolved into the constraints $a = Int$ and $b = Bool$}
}

\newglossaryentry{core}
{ name={Core Erlang},
  description={An intermediate language in the Erlang compilation suite}
}

\newglossaryentry{currying}
{ name={currying},
  description={Translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions that take a single argument and return a new function}
}
%The process of transforming a function which takes a tuple of \texttt{n} arguments into one which takes one argument at a time.

\newglossaryentry{depgraph}
{ name={dependency graph},
  description={\todo{fyll}}
}

\newglossaryentry{hmtypesystem}
{ name={Hindley-Milner type system},
  description={A type system for the lambda calculus with parametric polymorphism. Also known as Damas-Hindley-Milner}
}

\newglossaryentry{polymorph}
{ name={polymorphism},
  description={parametric polymorphism: a function or type declared with generic parameters that handles them identically. Ex. the identity function id has type $\forall a . a \to a$}
}

\newglossaryentry{seman}
{ name={semantic analysis},
  description={In the context of compiler construction semantic analysis is performed after lexing and parsing and checks for errors which can't be captured by the grammar of the language. For example that variables are defined before their use. Type checking is one kind of semantic analysis}
}

\newglossaryentry{topsort}
{ name={topological sorting},
  description={A topological sort of a directed graph is an ordering of its vertices such that for each edge $uv$ from vertex $u$ to vertex $v$, $u$ comes before $v$. A \acrshort{dag} always has at least one topological sorting}
}

\newglossaryentry{typechecking}
{ name={type checking},
  description={The process of finding a type of an expression}
}

\longnewglossaryentry{typesystem}
{ name={type system} }
{A type system is a formal system wherein types of expressions can be infered. Infering a type amounts to proving the type using the inference rules of the formal system.

Type systems are used to prove certain tractable properties of the code. For example that arithmetic operators are only applied to numeric values. Properties like termination and total function definitions are often left out of type systems since those problems are undecidable (intractable).
}

\newglossaryentry{typevar}
{ name={type variable},
  description={A variable representing some type}
}

\longnewglossaryentry{unification}
{ name={unification} }
{Two types $A$, $B$ are unifiable if there exists a substitution $S$, from type variables to types, such that $S(A) = S(B)$.

For example unifying a type (variable) $a$ with the type $Int$ would yield a substitution $S = [a/Int]$ since $S(a) = [a/Int]a = Int = [a/Int]Int = S(Int)$.
}
