% Uses glossary package

% A new entry:
%
% \newglossaryentry{<label>}
% { name={<theword>},
%   description={<Explaning text>}
% }


% A new acronym
%
% \newacronym{<label>}{<abbrv>}{<full>}

%\todo{Assigned to everyone}
%\todo{Screen useful entries}

\newacronym{ast}{AST}{abstract syntax tree}
\newacronym{adt}{ADT}{algebraic data type}
\newacronym{bif}{BIF}{built in function}
\newacronym{bnf}{BNF}{Backus-Naur form}
\newacronym{dag}{DAG}{directed acyclic graph}
\newacronym[description={Strongly connected component. A subset of a directed graph in which there is a path from any vertex to all others}]{scc}{SCC}{strongly connected component}

% Type inference category

\newglossaryentry{arity}
{ name={arity},
  description={The arity of a function is the number of arguments it accepts},
  plural={arities}
}

\newglossaryentry{algow}
{ name={algorithm W},
  description={Algorithm W is an algorithm which infers the types of expressions in the Hindley-Milner type system}
}

\newglossaryentry{beam}
{ name={BEAM},
  description={Erlang's Virtual Machine}
}

\longnewglossaryentry{bnfc}{ name={BNF Converter}}{A program developed at Chalmers for converting BNF grammar to a lexer and parser. See reference \cite{bnfc}}

\newglossaryentry{constraint}
{ name={constraint},
  description={A constraint is an equality statement between two types. The constraint $Int \to Bool = a \to b$ will, as an example, be resolved into the constraints $a = Int$ and $b = Bool$}
}

\newglossaryentry{core}
{ name={Core Erlang},
  description={An intermediate language in the Erlang compilation suite}
}

\newglossaryentry{currying}
{ name={currying},
  description={The process of transforming a function which takes a tuple of \texttt{n} arguments into one which takes one argument at a time. When the curried version of \texttt{f} has been applied to \texttt{n} arguments, it returns the result of passing a tuple containing those arguments to \texttt{f}}
}

\newglossaryentry{hmtypesystem}
{ name={Hindley-Milner type system},
  description={A type system for the lambda calculus with parametric polymorphism. Also known as Damas-Hindley-Milner}
}

\newglossaryentry{polymorph}
{ name={polymorphism},
  description={parametric polymorphism: a function or type declared with generic parameters that handles them identically. Ex. the identity function id has type $\forall a . a \to a$}
}

\newglossaryentry{seman}
{ name={semantic analysis},
  description={In the context of compiler construction semantic analysis is performed after lexing and parsing and checks for errors which can't be captured by the grammar of the language. For example that variables are defined before their use. Type checking is one kind of semantic analysis}
}

\newglossaryentry{topsort}
{ name={topological sorting},
  description={A topological sort of a directed graph is an ordering of its vertices such that for each edge $uv$ from vertex $u$ to vertex $v$, $u$ comes before $v$. A \acrshort{dag} always has at least one topological sorting}
}

\newglossaryentry{typechecking}
{ name={type checking},
  description={The process of proving types of an expressions}
}

\longnewglossaryentry{typesystem}
{ name={type system} }
{A type system is a formal system wherein types of expressions can be inferred. Inferring a type amounts to proving the type using the inference rules of the formal system.
}

\longnewglossaryentry{unification}
{ name={unification} }
{Two types $A$, $B$ are unifiable if there exists a substitution $S$, from type variables to types, such that $S(A) = S(B)$.

For example unifying a type (variable) $a$ with the type $Int$ would yield a substitution $S = [a/Int]$ since $S(a) = [a/Int]a = Int = [a/Int]Int = S(Int)$.
}
