\section{Code quality and user interaction}

\subsection{Documentation}

A general consensus between group members to keep the code base well documented were not followed up or enforced by the group. This led to parts of the code being very well documented and others being less readable and understandable than preferred. This is something that could be fixed and should be if the Hopper language project is continued.

\subsection{Testing}

Plans for a thorough test suite were fulfilled and kept for a while but with the incremental changes made to the compiler pipeline maintaining the test code proved a challenge as tests became outdated. When a more stable pipeline is up this could once again be a priority.

\subsection{Usability}

The intent was for the language and compiler to be user friendly with an easy to use syntax, descriptive error messages and adequate warnings for optimizable code.

For the resulting prototype of the project, and the features it contains, the goal of an easy to use syntax is mostly fulfilled. The resemblance between Hopper code and Haskell code is evident and should make Hopper accessible to many functional programmers. % too vague? -> mostly fufilled

Error messages and warnings were designed but not implemented. The project focused on getting the compiler working for correct code to begin with and did not reach a point where these additions could be made.

% designed but not implemented, we focused on the compiler working for correct code to begin with, no meta information being passed on in the compiler pipeline yet

% Could be used as the pure part in an application. For example using Hopper to implement an difficult algorithm but using Erlang as the glue to the rest of the system. 

%% Something like: Furthermore, a compiler should be user friendly in the sense of giving descriptive error messages for faulty code, give warnings about inconvenient code, etc.
