\section{Code quality and user interaction}

For the language and compiler to be considered useful in a context outside of the bachelors thesis there are some criteria which need to be fulfilled, for example descriptive error messages and good documentation.
This section discusses choices made in regards to usability.

\subsection{Documentation}

A general consensus between group members to keep the code base well documented was not followed up or enforced by the group. This led to parts of the code being very well documented and others being less readable and understandable than preferred. This is something that could be fixed and should be if the Hopper language project is continued.

\subsection{Testing}

Plans for a thorough test suite were followed initially. However, large changes made to the compiler pipeline made maintaining the test code a challenge as tests quickly became outdated. A stronger focus on testing and maintenance could have led to more reliable code. When a more stable pipeline is up this could once again be a priority.

\subsection{Usability}

The intent was for the language and compiler to be user friendly with an easy to use syntax and descriptive error messages.
For the resulting prototype of the project and the features it contains, the goal of an easy to use syntax is mostly fulfilled. The resemblance between Hopper code and Haskell code is evident and should make Hopper accessible to many functional programmers. % too vague? -> mostly fulfilled
Error messages and warnings were designed but not implemented. The project focused on getting the compiler working for correct code to begin with and did not reach a point where these additions could be made.

\subsection{Interoperability}

The fact that the Hopper compiler generates BEAM modules allows for a degree of interoperability: Hopper modules may be integrated in applications written in Erlang. Some parts of the compiler are prepared for enabling Hopper code to make use of modules written using Erlang. This would enable Hopper written code to access the already established Erlang library, and opens up for a future where Hopper written libraries may be accessed in Erlang written applications.
