\section{Code generator}

\todo{Assignee Liam}

Generally the last step of a compiler is the code generation step. The code generator
component should take an \gls{ast} much like one of the target language and translate it
to actual code strings of the target language. Additionally, this component may also
perform some optimizations on the generated code before returning it.

\subsection{Implementation}

The code generator is implemented using the Language.CoreErlang \cite{CoreErlang} package
from Hackage (maybe also bibliography link, or glossory). This package contains a Core Erlang
parser, a data structure used for representing Core Erlang \gls{ast}s and a pretty printer for
said data structure. The code generator makes use of this package by building Core Erlang
\gls{ast}s and then simply invoking the pretty printer on them to  produce Core Erlang.

\subsection{Function applications}
\todo{Include nice example figure! Liam knows what kind of function will be a good example}
%Good example: map (add 1) xs

A substantial difference between Haskell and Erlang is how functions are applied to arguments. 
In Haskell, all functions are of arity 1, and when functions are applied to several arguments, they are curried during runtime. This means that functions can be partially applied, in which case they return a function. This is useful for (among other things) the ability of composing new functions from already defined ones in a terse manner.

In Erlang, a function is identified by its name and its arity, and can only be applied to a number of arguments that is exactly that of its arity. %Anonyma funktioner har fortfarande fixed aritet
However, the types of the parameters passed are not significant when the function is called (though they may be of significance when the function body is evaluated), and function names can be shared by different functions if they have different arities.

Hopper attempts to preserve Haskell's support for partial application. This, in combination with the fact that the Erlang compiler requires all function definitions to have a determined arity at compile time, results in the translation of functions being one of the non-trivial tasks of the code generator.%Inte en subjektiv bedömning

We solve this by defining and calling an Erlang function curry, which turns all expressions either into functions of arity one or non-function values. The solution Hopper provides is a small Erlang function which adds the ability to curry function during runtime. \todo{explain the curry solution in more detail, add curry.erl fil i appendix}

\subsection{Algebraic data types and constructors}

Another area where Haskell and Erlang differ is the use of \glspl{adt}. These kind of data types do not exist in Erlang in the same way as they do in Haskell, i.e. with their heavy reliance
on constructors. When using pattern matching in Erlang, an entity called atom is instead used for
handling specific cases. An atom is a literal constant with a name. Variables can hold atoms, and said variables can be pattern matched over different atoms for identifying different cases. %Håller int med om behövd omformulering

In Hopper, \glspl{adt} are implemented and translated to Core Erlang in two specific cases: when they are processed, and when they are declared. Like in Haskell, variables in Erlang can
hold any value, so the only problem to solve was how the values of \glspl{adt} should be represented in Erlang. The solution drew inspiration from the book \textit{Implementing functional languages: a tutorial} \cite{FunTutorial}, which (among other things) describes an approach to this problem where the values of \glspl{adt} are translated to tuples, holding the constructors (represented by unique integer values) as a tag, and their additional values. %SPJ referensen är bra, det pekar på att vi har observerat en redan etablerad teknik (dessutom etablerad av en såpass erkänd individ), och tagit inspiration av den. Framförallt ska vi inte utelämna att vi har blivit inspirerade, det skulle kunna se ut som vi påstår att vi kommit på det själva då, vilket vi inte har
\Glspl{adt} in Hopper are translated in the same manner, but translates the constructors to atoms instead, to mimic the conventional structure of data in Erlang. Declared constructors are simply translated to functions, that takes a number of parameters (if any), and returns the value as a tuple representation as described above. %Värt att nämnas igen, första gången beskriver hur det funkar generellt, här poängterar vi att vi gör "likadant"


\begin{figure}[!htb]
\centering
\begin{lstlisting} 
data Tree = Tree Int Tree Tree | Empty

Tree 5 (Tree 3 (Tree 1 Empty Empty) 
               (Tree 4 Empty Empty)) 
       (Tree 7 Empty Empty)
\end{lstlisting}
\caption{Hopper ADT with example value}
\label{lst:hopperAdt}
\end{figure}

\begin{figure}[!htb]
\centering
\begin{lstlisting} 
{'Tree', 5, {'Tree', 3, {'Tree', 1, 'Empty', 'Empty'},
                        {'Tree', 4, 'Empty', 'Empty'}},
            {'Tree', 7, 'Empty', 'Empty'}}
\end{lstlisting}
\caption[Core Erlang translation of constructor and example value]
 {Core Erlang translation of the Hopper constructor and example value seen in figure \ref{lst:hopperAdt}}
\label{lst:coreAdt}
\end{figure}

\todo{Include example figure of constructors. Caption should tie in with fun app sub section}

\subsection{Emulating the erlang compiler}

One downside to the choice of compiling to Core Erlang and then invoking the erlc
(bibliography link here) is the loss of the additions and optimizations the erlc
compiler makes when it compiles Erlang to Core Erlang in its pipeline. To deal with this
the code generator has been given additional functionality to emulate the pre Core Erlang
behaviour of the erlc compiler. \todo{Mention the non matching case exception}