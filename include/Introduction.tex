\chapter{Introduction}

There is a trend toward more type checking, more concurrency, and more parallellism in modern programming languages as seen in Swift\cite{swift} and Rust\cite{rust}. Type checking to manage correctness in ever more complex systems, concurrency to manage large distributed systems and parallellism to utilize the growing number of cores available in computers. There currently exist eminent languages in each of these categories.

\section{Problem}

Each of these concerns have spawned viable solutions, notably Haskell\cite{haskell} for type systems and Erlang\cite{erlang} for concurrency and parallellism. But as far as the group knows there has been few successful attempts at combining these solutions in a language which offer the benefits of an strong type system togheter with the benefits of native concurrent and parallell features. We will take on the challenge of combining the merits of these fields in a new programming language called Hopper endowed with an expressive type system and with native facilities for concurrent and parallell programming. The question that the project aims to answer is whether a prototype for this new language can be implemented in such a way that it is powerful, containing the desired features, and usable.

\section{Purpose}

We hope this report will give some insight into problems that arise in the melding of type systems with concurrent and parallell capabilities as well as provide som guidance in how they could be solved or in worst case how they should not be solved. This report might interest the programming language community and serve as a springboard into a more exhaustive attempt at integrating type systems with concurrent and parallell capabillities.

\section{Scope}

As programming language design and implementation is an complex field of study we will need to limit the ambition of the project to fit the format of a bachelors thesis. Our aim is to create a prototype of the finished language. This give us some room to prioritize design at the expense of implementation details.  

\section{Report overview}

In the following chapters we want to take the reader through some preliminaries to the design and implementation of the language to finally end up in discussion of the results and methodology.\\
Chapter 2 details a short history and background of the technological frameworks. \\
Chapter 3 explains the methodology used by the group and describes some project management tools. \\
Chapter 4 explains the algorithms and implementation decisions made developing the prototype. \\
Chapter 5 takes inventory of the results achieved in the project. \\
Chapter 6 contains a discussion of the results. \\
Chapter 7 concludes the report with some final thoughts.
