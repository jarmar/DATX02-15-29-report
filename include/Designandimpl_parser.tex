\section{Parser}

The parser is implemented by writing a \gls{bnf} grammar and feeding it to the BNFC \cite{bnfc} tool. BNFC, as described in the background, is the BNF Converter developed at Chalmers which the group used to automatically generate a lexer and a parser.

To have as clean syntax as Haskell, the grammar should be indentation sensitive instead of depending on braces and semicolons as in C-like languages. Parsing code with braces and semicolons is easier because one does not need to keep track of which indentation context the code is in. BNFC can help with this by converting an indentation sensitive language to a brace dependent one. It does this in the lexer by inserting tokens around expressions, making it easy to match against these in the parser.

\subsection{The grammar}

Writing the grammar one describes the ways in which programs accepted in the language can be written. Hence it takes great consideration to ensure that the grammar allows everything that the language is supposed to be able to express but disallows everything else. This does not include expressions that are semantically wrong. To deal with this, semantic analysis of the \gls{ast} can be done with a type checker, for instance. 

The grammar in the project was produced in incremental steps that allowed more and more syntax to be added. This made it possible to have functionality implemented through the whole pipeline before new syntax was added. 

A full rewrite of the grammar was done half way through the project. The reason for this was that some grammatical rules were intertwined and that the understanding of how a correct grammar should be defined had been improved. The new grammar was more modular which also made further extensions easier.

Some syntactic sugar for \texttt{if-then-else} was implemented and more was planned, for example sugar for lists and tuples.
