\chapter{Discussion}

\todo{Assigned Johan L}

\todo{PLEASE EXPAND ON THESE AND ADD COMMENTS IF YOU THINK OF ANYTHING, APPLIES TO ALL DISCUSSED TOPICS, OK TO ADD TOPICS}

\todo{WHEN STATING THAT SOMETHING IS A GOOD OR BAD RESULT MAKE SURE THAT IT IS CLEAR WHY WE FEEL THAT IT IS GOOD OR BAD, IF APPLICABLE}

\section{Implementation discussion}


\todo{Not everything made it but...
we aimed for working prototype,
learning was one of the goals,
we have seen some results.
Discuss what was stated in the results!
Discuss why the stuff that didn't make it in didn't.
Summarize results in conclusion!}


\todo{(FOR ALL COMPONENTS) Talk about features, which are good, which are not so good? Tradeoffs (Consequences of design choices, what was gained, what was "lost")}

\subsection{Parser}
% Layout

\subsection{Renamer}
% How it's doing everything at the same time, could maybe abstract out thing a bit and do in multiple stages
% Everything follows that same pattern is good. 
% Testing was simplified by the BNFC module TestHopper

\subsection{Dependency check (order? after parser?)}

\subsection{Type checker}
% Multiple versions 
% should method related type checker problems be included here?

\subsection{Code generator}

%Talk about BIFs here?
%Where to hack into erlc, why core erlang. here or design and impl?


\subsection{Documentation}

A general consensus between group members to keep the code base well documented were not followed up or enforced by the group. This led to parts of the code being very well documented and others being less readable and understandable than preferred. This is something that can easily be fixed and should be if the Hopper language project is continued.

\subsection{Testing}

Plans for a thorough test suite were fulfilled and kept for a while but with the incremental changes made to the compiler pipeline maintaining the test code proved a challenge as tests became outdated. When a more stable pipeline is up this could once again be a priority.

\subsection{Usability}
\todo{better name?}

%% Something like: Furthermore, a compiler should be user friendly in the sense of giving descriptive error messages for faulty code, give warnings about inconvenient code, etc. 



\section{Methods discussion}

\subsection{Agile development - sprint length}

Sprint lengths were initially short and had small incremental goals. This worked well for parts of the compiler where the structure was relatively flat and new content could be added without affecting old content to a greater extent. One notable exception was the type checker where implementing a small subset proved to be a big challenge. Longer sprints would probably have seen the same difficulties though since they were due to differences between compiler parts more than the sprint lengths.

\subsection{Lack of daily communication}

Not having continuous follow-ups might have prolonged the difficulties in getting the full pipeline working. The weekly meetings had the long term plans running but not much insights into the detailed problems discovered in each part. Workshops were held to emphasize group work and communication channels were set up to have group members help each other but some problems were discovered a bit later than might have been with more frequent face to face meetings.

\subsection{Lack of project leader}

No one person had the responsibility to catch on to potential problems and make sure they were handled. Each group member worked independently or with other group members assigned to the same compiler phase but were only incentivized to ask for help when it was needed. Further, appointing a technical lead responsible for specifying the interfaces between components (i.e. the datatypes representing the program and the type signatures of exported functions) could have made it easier for members to use code they hadnâ€™t themselves written.

\subsection{Lack of hard specification}

Starting the project the group agreed on potential features that could be added to the language. A list of such features was compiled to use as a general direction in which to take development. The incremental development approach that then followed, beginning with a small subset of the language, quickly lost track of these inital goals. This meant that group members mostly made their own decisions about what steps to take in the development of their areas of responsibility. For the most part this worked fine but in some cases it led to too much freedom and decisions that should possibly have been made as a group were made by fewer members.

\subsection{Revision control system}

The use of Git as our revision control system was successful. The ease of branching, working locally and merging was a good fit for the group dynamic employed. 
There were times during the project when the number of branches rose a bit high. With six group members there should often not be a need for eight or nine simultaneous versions of the code. Efforts were made to merge branches and keep the number low with one working branch and specific branches for new features being developed.

\subsection{Type checker branches}

The type checking took two different directions early on which led to two separate branches. They were in some ways similar in concept but different in their approach to the subject. This led to time lost both through other compiler phases waiting for a functioning type checker and through one of the branches in the end being discarded in favor of the other, working, branch. The type checker development was in many ways not suited for the incremental growth that the project started with. Beginning from a smaller grammar and expanding it felt natural but there was no easy way of beginning with a small type checker. Since the type checking was also a heavy theoretical subject there were many sprint cycles before any useful code was added to the type checker in the compiler pipeline. 

\subsection{Responsibility rotation}
\todo{better name?}

The initial idea for the project was to have all group members work on every part of the project. This would not only support the learning goals of the project but would also ensure that each member of the team wrote code in each of the modules. This could have made it easier for team members to make their own modifications to any module when needed, thus avoiding large latencies and deadlocks caused by the need for alteration to some other compiler phase. 
Beginning with the small subset of Hopper there was a division into groups which, given the problems with the type checker, unfortunately became static.



\todo{maybe someone could write about libraries?}

Libraries?
- Core Erlang library broke in GHC 7.10
- Core Erlang made code generator implementation easier. The similarities between Hopper and Core Erlang ADT's enabled the use of the library, and that releived the project from most string operations


\section{Possible future}
% It is on git, just to fork and continue 

\todo{write something here}