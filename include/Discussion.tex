\chapter{Discussion}

\todo{Assigned Johan L}

\todo{PLEASE EXPAND ON THESE AND ADD COMMENTS IF YOU THINK OF ANYTHING, APPLIES TO ALL DISCUSSED TOPICS, OK TO ADD TOPICS}

\todo{WHEN STATING THAT SOMETHING IS A GOOD OR BAD RESULT MAKE SURE THAT IT IS CLEAR WHY WE FEEL THAT IT IS GOOD OR BAD, IF APPLICABLE}

\todo{Not everything made it but...
we aimed for working prototype,
learning was one of the goals,
we have seen some results.
Discuss what was stated in the results!
Discuss why the stuff that didn't make it in didn't.
Summarize results in conclusion!}


\todo{(FOR ALL COMPONENTS) Talk about features, which are good, which are not so good? Tradeoffs (Consequences of design choices, what was gained, what was "lost")}

\section{Parser}
% Layout
In BNFC the layout functionallity isn't very much explained. What we had to do to understand this was to look at examples and the BNFC source code and generated source code for our parser. This was difficult and we still don't have full understanding of when the layout rule is activated but we suppose it is similar how other layout parsers does it. % This is just fill out text that doesn't mean much

\section{Renamer}
% How it's doing everything at the same time, could maybe abstract out thing a bit and do in multiple stages
As an outsider looking at the source for the renamer module it can be hard do grab all of what it does. It would be a nice improvment to abstract out the traversal of the tree and split up the different responsibilities the renamer has. This would help with making less bug prone code and also allow others to add functionality and fix bugs not just the responible person for that module. 

% Everything follows that same pattern is good. 
% Testing was simplified by the BNFC module TestHopper

\section{Dependency check}

\section{Type checker}
% Multiple versions 
% should method related type checker problems be included here?

\section{Code generator}

%Talk about BIFs here?
%Where to hack into erlc, why core erlang. here or design and impl?

\subsection{Core Erlang}

The choice of Core Erlang as a target language was proven favorable. The structure of a Hopper module and a Core Erlang module was resembling enough to make sure that many translation cases were trivial. It also enabled the use of the Langauge.CoreErlang \cite{CoreErlang} package, which made sure that the target code could be generated by building an \acrshort{ast} and then invoking the included pretty printer. The fact that the Erlang compiler can take Core Erlang as input enabled this choice. Early in the project, BEAM instruction code was considered as the target language, but the idea was discarded since Core Erlang was proven more adapt.

\subsection{Algebraic data types and constructors}

The approach to translate \acrshort{adt}'s to tuples tagged with atoms was deemed successful. The generated beam code operates as expected, and is fairly analogue with beam code generated from Erlang code from a run time point of view. However, if values generated with Hopper constructors were to be accessed from Erlang written code, it would prove tedious since the user would have to write out the tuple representations of the \acrshort{adt}'s manually. In this case it would also be required that the user understands how Hopper \acrshort{adt}'s are translated.

\subsection{Function applications}

Function applications were attempted to be implemented as closely to Haskell's function application functionality as possible. This meant that the function applications written in Hopper would result in the function being curried at run time. One could argue that this adds overhead, but this overhead was deemed trivial, since it is relative to the arity of the function, which at any time should be small. In addition, all functions are generated in two ways, one where the run time curried solution is used, and one where the full arity is used. The first case would be used internally by Hopper, while the second one permits all Hopper functions to be used from Erlang, which supports  the criteria of interoperability.

\section{Code quality and user interaction}

\todo{make documentation/testing/usability into sections if they grow enough in size}

\subsection{Documentation}

A general consensus between group members to keep the code base well documented were not followed up or enforced by the group. This led to parts of the code being very well documented and others being less readable and understandable than preferred. This is something that could be fixed and should be if the Hopper language project is continued.

\subsection{Testing}

Plans for a thorough test suite were fulfilled and kept for a while but with the incremental changes made to the compiler pipeline maintaining the test code proved a challenge as tests became outdated. When a more stable pipeline is up this could once again be a priority.

\subsection{Usability}
\todo{better name?}

%% Something like: Furthermore, a compiler should be user friendly in the sense of giving descriptive error messages for faulty code, give warnings about inconvenient code, etc. 


\section{Methods discussion}

\subsection{Agile development - sprint length}

Sprint lengths were initially short and had small incremental goals. This worked well for parts of the compiler where the structure was relatively flat and new content could be added without affecting old content to a greater extent. One notable exception was the type checker where implementing a small subset proved to be a big challenge. Longer sprints would probably have seen the same difficulties though since they were due to differences between compiler parts more than the sprint lengths.

\subsection{Lack of daily communication}

Not having continuous follow-ups might have prolonged the difficulties in getting the full pipeline working. The weekly meetings had the long term plans running but not much insights into the detailed problems discovered in each part. Workshops were held to emphasize group work and communication channels were set up to have group members help each other but some problems were discovered a bit later than might have been with more frequent face to face meetings.

\subsection{Lack of project leader}

No one person had the responsibility to catch on to potential problems and make sure they were handled. Each group member worked independently or with other group members assigned to the same compiler phase but were only incentivized to ask for help when it was needed. Further, appointing a technical lead responsible for specifying the interfaces between components (i.e. the datatypes representing the program and the type signatures of exported functions) could have made it easier for members to use code they hadnâ€™t themselves written.

\subsection{Lack of hard specification}

Starting the project the group agreed on potential features that could be added to the language. A list of such features was compiled to use as a general direction in which to take development. The incremental development approach that then followed, beginning with a small subset of the language, quickly lost track of these inital goals. This meant that group members mostly made their own decisions about what steps to take in the development of their areas of responsibility. For the most part this worked fine but in some cases it led to too much freedom and decisions that should possibly have been made as a group were made by fewer members.

\subsection{Revision control system}

The use of Git as our revision control system was successful. The ease of branching, working locally and merging was a good fit for the group dynamic employed. 
There were times during the project when the number of branches rose a bit high. With six group members there should often not be a need for eight or nine simultaneous versions of the code. Efforts were made to merge branches and keep the number low with one working branch and specific branches for new features being developed.

\subsection{Type checker branches}

\todo{keep this under methods discussion or move to type checker implementation discussion?}

The type checking took two different directions early on which led to two separate branches. They were in some ways similar in concept but different in their approach to the subject. This led to time lost both through other compiler phases waiting for a functioning type checker and through one of the branches in the end being discarded in favor of the other, working, branch. The type checker development was in many ways not suited for the incremental growth that the project started with. Beginning from a smaller grammar and expanding it felt natural but there was no easy way of beginning with a small type checker. Since the type checking was also a heavy theoretical subject there were many sprint cycles before any useful code was added to the type checker in the compiler pipeline. 

\subsection{Responsibility rotation}
\todo{better name?}

The initial idea for the project was to have all group members work on every part of the project. This would not only support the learning goals of the project but would also ensure that each member of the team wrote code in each of the modules. This could have made it easier for team members to make their own modifications to any module when needed, thus avoiding large latencies and deadlocks caused by the need for alteration to some other compiler phase. 
Beginning with the small subset of Hopper there was a division into groups which, given the problems with the type checker, unfortunately became static.



\todo{maybe someone could write about libraries?}

Libraries?
- Core Erlang library broke in GHC 7.10
- Core Erlang made code generator implementation easier. The similarities between Hopper and Core Erlang ADT's enabled the use of the library, and that releived the project from most string operations


\section{Possible future}
% It is on git, just to fork and continue 

\todo{write something here}