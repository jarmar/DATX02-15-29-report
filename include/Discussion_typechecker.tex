\section{Type checker}

Since Hopper was designed to be similar to Haskell in terms of its syntax and type system and Haskell's system is based on the \Gls{hmtypesystem}, it was the obvious choice. The existence of relevant material~\cite{implfun} on implementing such a type checker eased development considerably. 

In addition to implementing Hindley-Milner, the type system contains a number of interesting ideas. It implements a function which provides access to arbitrary Erlang functions given their name and arity as an argument. In a production version of Hopper, this functionality would be wrapped and provided with a user friendly syntax. It also gives access to type safe and non type safe message passing in an experimental form, allowing for processes written in Hopper to both communicate in a type safe way with each other and with processes written in Erlang in a non type safe way. Hopper's experimental form of ad-hoc polymorphism allows for type safe sending of messages, but is less powerful than Haskell's and would likely be replaced in production Hopper.

\subsection{Algebraic data types and constructors}

The approach to translate \glspl{adt} to tuples tagged with atoms was deemed successful. The generated beam code operates as expected, and is fairly analogue with beam code generated from Erlang code from a run time point of view. However, if values generated with Hopper constructors were to be accessed from Erlang written code, it would prove tedious since the user would have to write out the tuple representations of the \glspl{adt} manually. In this case it would also be required that the user understands how Hopper \glspl{adt} are translated.