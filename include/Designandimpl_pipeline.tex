\section{The compiler pipeline}

\todo{Assigned Jakob}

% PIPELINE FIGURE

\todo{Update figure: Typechecker -> Type checker, dependency checker}

\begin{figure}[h!]
\centering
  \includegraphics[width=0.6\pdfpagewidth]{figure/pipeline}
  \caption{Hopper's pipeline}
  \label{fig:pipeline}
\end{figure}

% HOW IS HOPPER BUILT

As seen in figure~\ref{fig:pipeline} the Hopper language has five steps in its compiler
pipeline before it turns over to the Erlang compiler. Each step works on the 
source code representation in a uniqe way. The steps can be summerized as
follows. The lexer and parser reads in text files and converts them to an 
abstract representation, the renamer then simplifies this representation for the 
type checker whose job it is to control the types of all the expressions. Lastly 
there is another simplifying step before the code generator which produces Core
Erlang code. The Erlang compiler is then invoked, using the produced Core Erlang
code, and the result is Erlang assembly code that is run on the BEAM VM.
