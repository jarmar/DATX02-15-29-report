\section{Code generator}

\subsection{Core Erlang}

The choice of Core Erlang as a target language was proven favorable. The structure of a Hopper module and a Core Erlang module was resembling enough to make sure that many translation cases were trivial. It also enabled the use of the Language.CoreErlang \cite{CoreErlang} package, which made sure that the target code could be generated by building an \gls{ast} and then invoking the included pretty printer. The fact that the Erlang compiler can take Core Erlang as input enabled this choice. Early in the project, BEAM instruction code was considered as the target language, but the idea was discarded since Core Erlang was proven more adept.

\subsection{Algebraic data types and constructors}

The approach to translate \glspl{adt} to tuples tagged with atoms was deemed successful. The generated beam code operates as expected, and is fairly analogue with beam code generated from Erlang code from a run time point of view. However, if values generated with Hopper constructors were to be accessed from Erlang written code, it would prove tedious since the user would have to write out the tuple representations of the \glspl{adt} manually. In this case it would also be required that the user understands how Hopper \glspl{adt} are translated.

\subsection{Function applications}

Function applications were attempted to be implemented as closely to Haskell's function application functionality as possible. This meant that the function applications written in Hopper would result in the function being curried at run time. One could argue that this adds overhead, but this overhead was deemed trivial, since it is relative to the arity of the function, which at any time should be small. In addition, all functions are generated in two ways, one where the run time curried solution is used, and one where the full arity is used. The first case would be used internally by Hopper, while the second one permits all Hopper functions to be used from Erlang, which supports  the criteria of interoperability.