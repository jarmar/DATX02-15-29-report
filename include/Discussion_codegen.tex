\section{Code generator}

The choice of Core Erlang as a target language proved favorable. The structure of a Hopper module and a Core Erlang module are similar enough that many translation cases are trivial. It also enabled the use of the \texttt{Language.CoreErlang} \cite{CoreErlang} package, which enabled generating the target code by building an \gls{ast} and then invoking the included pretty printer. The fact that the Erlang compiler can take Core Erlang as input made this choice possible. Early in the project, BEAM instruction code was considered as the target language, but the idea was discarded since Core Erlang proved more suitable given the similarities in the \glspl{ast}, as well as the sparse documentation for BEAM.

\subsection{Function applications}

The goal for Hopper function applications was to make their behavior as close to Haskell's function applications as possible. This meant that the function applications written in Hopper would result in the function being curried at run time. One could argue that this adds overhead, but this overhead was deemed trivial, since it is relative to the \gls{arity} of the function, which at any time should be small. In addition, two versions of each function are generated, one where the run time curried solution is used, and one where the full arity is used. The first case is used internally by Hopper, while the second one permits all Hopper functions to be used from Erlang, making it more interoperable with the language.