\section{Type checker}

\todo{Assigned to Liam}

\subsection{The type system}
<Det jag skrev om TC idag>
2.4 (Rename to Type Inference)
Hopper’s type system is intended to be a less powerful version of Haskell’s.  That means that any program that typechecks in Hopper should typecheck in Haskell, but not necessarily vice versa (there is not yet any support for type classes, for example).  We have chosen to use the Hindley-Milner type system as described in Simon Peyton-Jones’ ‘The Implementation of Functional Programming Languages’. It allows for parametric polymorphism (e.g. id :: a -> a; id x = x), higher order functions (e.g. map \_ Nil = Nil; map f (Cons x xs) = Cons (f x) (map f xs) and datatypes with type arguments, e.g. data List a = Cons a (List a) | Nil. Currently the type checker is making types too general, so some things that shouldn’t compile do
(Det jag skrev om TC idag)
\\
Hopper uses the Damas-Hindley-Milner (HM) type system for the lambda calculus. HM has parametric polymorphism enabling (wording, what do I mean and what does this say???) type inference of type schemes - types with generic, quantified type variables. Further HM has the Algorithm W which not only infers the most general type for expressions but also has existing soundess and completeness proofs. These proofs means that for our well formed expressions we will always find a type and that it will be the correct type.

\subsection{Preprocessing}

Damas-Hindley-Milner is a type system for the lambda calculus and the parsed Hopper code has a different representation. The parsed code is transformed into an AST and the expressions written in Hopper is turned into semantically equivalent expressions in the lambda calculus. Hopper type inference is done on a simple language which is lambda calculus extended with let expressions and the fixpoint combinator. Lambda calculus in itself is Church-Turing complete and could thus represent these added constructs but they simplify ... (add stuff here)

\begin{description}
\item[The simple language] \hfill
\begin{description}
  \item[Variables] \hfill \\
    A variable is an expression.\\
    Ex. x is a valid expression.
   \item[Abstraction] \hfill \\
    An abstraction of a variable over some expression. (wording?)\\
    Ex. (\textbackslash x . x) is a valid expression.
   \item[Application] \hfill \\
    An application of an expression to another expression is an expression.\\
    Ex. (f x) is a valid expression.
   \item[Extensions] \hfill
\begin{description}
    \item[Let] \hfill \\
      A let expression, defining a variable within the scope\\
      of an expression, is an expression.\\
      Ex. (let x = n in (f x)) is a valid expression. 
    \item[Fix] \hfill \\
      The fixpoint combinator enables recursive expressions.\\
      A fixpoint combinator y satisfies y f = f (y f).
\end{description}
\end{description}
\end{description}

\subsection{Type inference with Algorithm W}

Where the original Algorithm W uses a top-down approach we have chosen to implement it using a bottom-up approach (sometimes called Algorithm M REF: generalizing hindley-milner type inference algorithms, Heeren,Hage,Swierstra ). The bottom-up approach generates constraints on the types in a first pass and then solves these constraints producing the most general type for each expression.

\begin{description}
  \item[Generating constraints by inference rules] \hfill \\
A first pass generates constraints on the types by a set of inference rules (see appendix). \todo{FILL OUT}
  \item[Solving constraints by solving rules] \hfill \\
Secondly we solve the inferred types using the accumulated constraints to produce the most general type for each expression. \todo{FILL OUT}
\end{description}
