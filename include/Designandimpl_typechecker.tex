\section{Type system}
%Doesn't just check, it infers
\label{sec:dai_tc}
\todo{Assigned to Liam}


Hopper's type checker is designed to provide compile-time guarantees about program behaviour on Erlang's BEAM virtual machine. To do this, it uses a variant of the Hindley-Milner type system upon which Haskell's system was initially based (add source, put in glossary?). While making Hopper's type system as powerful as Haskell's is today is beyond the scope of this project, Hindley-Milner still allows one to write useful typed programs. For example, one can define polymorphic data types and functions as in Haskell. For example, here is a definiton of lists and the Haskell function map :: (a->b) -> [a] -> [b] in Hopper: \\ \\
%Gör bilden fin plis!
data List a = Cons a (List a) | Nil \\
map f (Cons x xs) = Cons (f x) (map f xs) \\
map \_ \_ = Nil \\ 

Just as in Haskell, the type for map is inferred; in general, type signatures do not need to be given to functions.
%Borde jag skriva om konstruktorer här? De görs ju i TypeChecker-steget för att tillåta CodeGen att inte veta ngt. om typer.
\subsection{Implementation}
The type checking module is based on the standard algorithm for Hindley-Milner type checking, Algorithm W (put ref here). It works by taking a list of definitions. Definitions are tuples of a name, a syntax tree that represents the value the name is defined to be, and an optional type signature. The type checker then divides the definitions into those which have type signatures and those that do not. The definitions without are further divided into groups of mutually recursive definitions. Those groups are strongly connected components in the functions' /dependency graph/ (put glossary entry here). For example, given the module: \\ \\
module Example () where \\
noTypeSig = 3 \\
mutual1 = mutual2 \\
mutual2 = mutual1 \\
withTypeSig :: String \\
withTypeSig = "I'm well typed!" \\

noTypeSig will be divided into its own group of mutually recursive values, mutual1 and mutual2 will be in the same and withTypeSig will be treated separately. The next step is to infer the types of the definitions without type signatures. The mutually recursive groups are /topologically sorted/ (glossary entry?) so that any SCCs A which depends on another SCCs B already having been inferred is type checked after B. When a group of definitions (f1 = e1;f2 = e2 ... fn = en) is type checked and inferred, each name (f1 ... fn) is associated with a /type variable/ (glossary entry). Then the type of each expression (e1 ... en) is inferred by following a number of inference rules, which are best explained by example: \\ \\
Literals are given suitable types\\
3 :: Number \\
"String" :: String \\
Lambdas are of type a -> b, where a is the type of their argument and b the type of their result \\
f = \textbackslash 42 -> "The answer to life, the universe and everything" :: Number -> String \\
When an expression f :: a->b is applied to another expression x :: a, then the result has type b. \\
f 42 :: String\\
A named value whose type has already been inferred or has a type signature is assumed to have an /instance/ of that type where all type variables have a concrete type. For example, id :: a -> a will have the type a -> a for some /specific/ a. For example, in \\
foo :: a -> List a -> List a \\
foo x y = Cons (id x) (id y) \\
the first use of id has type (a->a) while the second has type (List a -> List a). Note that the type of id is polymorphic in the type of foo!\\
For the sake of brevity, not all rules have been mentioned. \\

These rules generate a number of equations on type variables, e.g. \\
"t = a -> a, List a = List Bool" \\ which are solved via a process called unification (glossary entry here). Unification converts such equations to a /constraint/: a map from type variables to types. In the above example, the solution would be "t = Bool -> Bool, a = Bool". Examples of equations with no solution are "Int = Bool" and "t = List t", which would generate an infinite type.
When the types of (f1 ... fn) have been inferred to be (t1 ... tn), (f1 ... fn) will be assumed to be of those types during the rest of the type checking process. Once all SCCs have had their types inferred, the types of the definitions with type signatures are checked. If at any point in the type checking process a unification fails the type checker fails with an error message.

\subsection{Additional features}
\subsubsection{Constructor definition}
It is worth mentioning in passing that the definition of constructors is done by the type checker. The arity of a constructor depends on its type: for example, Cons :: a -> List a -> List a has arity 2. Creating the definition in the type checker simplifies the code generation step by allowing it to know nothing about the types of expressions. For further information on constructors, read section 4.6.
\subsubsection{Prim.apply}
To access Erlang bifs, a special function Prim.apply :: String -> String -> Number -> a has had its type hardcoded into the type checker. Prim.apply is defined in the Erlang module Prim.erl and takes a module name, a function name and an arity and returns the requisite function. For example, addition can be defined by: \\
add :: Number -> Number -> Number
add = Prim.apply "erlang" "+" 2 

\subsection{Experimental features}

The following features were added at the last minute and are not officially part of Hopper. Their syntax and semantics are not representative of production-ready Hopper should such a product ever see the light of day; indeed, their design was largely decided by circumstance. However, the power they add to the language justifies their inclusion in this report.
\subsubsection{Implicit type arguments}
The Hindley-Milner type system allows for a certain kind of polymorphism, namely qualified polymorphism. That allows one to define functions such as "reverse :: List a -> List a" and "id :: a -> a" and have them work for any type "a". The actual runtime value of id or reverse doesn't vary based on the type. However, there is another kind of polymorphism that Haskell provides: ad-hoc polymorphism. The Haskell function "sum :: Num a => [a] -> a" is an example of an ad-hoc-polymorphic value. It implicitly takes a dict (a data structure containing numeric operations for the type a) and uses it to add up all the elements. The value of that dict varies based on the type sum is applied to. Hopper does things slightly differently: instead of passing a dict, it allows functions to take an implicit type argument. For example, the function \\
typeOf :: Implicit t -> t -> Type \\
typeOf t \_ = t \\
returns the type of its argument.
Ad-hoc polymorphism is essential for typesafe message passing: for a Hopper process to be able to distinguish between receiving two values of different type but with the same runtime representation (e.g. Nil :: List Number and Nil :: List Bool), the type of the value needs to be included in the message at runtime. Defining Hopper's send function to take the type of the message as an implicit type argument makes that possible. \\
Where to put this figure? \\
data T2 t m = T2 t m \\
--the type, message pair that receive expects \\
send :: Implicit t -> Pid -> t -> IO t \\
send typ pid x = mkIO (\textbackslash \_ -> Prim.apply "erlang" "!" 2 pid (T2 typ x)) \\

    

\subsubsection{Receive clauses}
A central part of Erlang is the sending and receiving of messages. Erlang has primitive support for a so-called receive clause, which pattern matches on a process' mailbox until a specified waiting period has passed or until it finds a match. For example, \\
receive true -> io:format("Received true!"); \\
        \{X,Y\} -> io:format("Received a pair!")\\
        after 3000 -> error(got\_nothing) end\\
waits for three seconds to receive either 'true' or a pair before crashing. The ability to pattern match on incoming messages is a powerful feature; without it, message handling becomes much more verbose. Since there is no support for receive clauses in the parser, (how to write this? passive tone?) I transformed \\ \\
case receive of \\
    pattern1 -> expr \\
    pattern1 -> expr2 \\
    ... \\
    After timeOut -> exprTimeOut \\ \\
into a receive clause in the typechecker. Typesafe receive expects values to be sent in a pair along with their type. For interoperability with Erlang, non-typesafe receive is also available with the syntax \\ \\
case unsafeReceive of \\
    pattern1 -> expr \\
    ... \\
    After timeOut -> exprTimeOut \\

To reflect the fact that they are impure, both forms of receive are of the type IO a, where a is the type of expr on the right-hand side of the case clauses.

\subsection{In short...}

Hopper's type system allows for polymorphic data types such as List and IO and polymorphic functions on them, typesafe message passing through send and receive, as well as a form of typeclasses. %Jag borde kunna skriva dessa exempel, beror på hur många buggar som poppar upp

%What do we do in TC/Convert?\

%•	Implement constructors (thus allowing codegen to have no knowledge of types)
%•	Give some functions implicit type arguments : abused syntax to achieve this. In some ways more powerful than Haskell’s class system (because it is done at runtime in normal Hopper), but more boilerplatey and performance intensive. Allowing values to vary based on their type (i.e. ad-hoc-polymorphism, where polymorphic values are more than just a black box, see Theorems for Free [reference?]) is essential for implementing typesafe message passing, because type information must be sent in messages at runtime to distinguish between values with same runtime representation but different types (e.g. an empty list of Booleans and an empty list of numbers).
%•	Implemented receive: abused syntax using case receive of ... -> ...
%•	A module that Converts to/from AST.AST. This is bad and is purely technical debt. Why it was created and maintained (two different ASTs, inertia, poor coordination) can be elaborated on in Discussion.
%•	Prim.apply\

%What can we do with the type system?\

%•	Higher order functions, a lot of that Haskelly goodness.
%•	IO, other types which describe processes and the connections between them. Because the BEAM is a high level VM designed for a dynamic programming language, coercing between types in Hopper does not have the same catastrophic consequences as in Haskell (which compiles to native machine code: coercing something on the heap can lead to a fatal crash e.g. because you treat a number as a pointer). That means it is rather comfortable to treat the same value as several different types in Hopper: for example a Number may be both a Natural and a Prime. We do not yet know where that leads, but it seems exciting. 



%Hopper uses the Damas-Hindley-Milner (HM) type system for the lambda calculus. HM has parametric polymorphism enabling (wording, what do I mean and what does this say???) type inference of type schemes - types with generic, quantified type variables. Further HM has the Algorithm W which not only infers the most general type for expressions but also has existing soundess and completeness proofs. These proofs means that for our well formed expressions we will always find a type and that it will be the correct type.

%\subsection{Preprocessing}

%Damas-Hindley-Milner is a type system for the lambda calculus and the parsed Hopper code has a different representation. The parsed code is transformed into an AST and the expressions written in Hopper is turned into semantically equivalent expressions in the lambda calculus. Hopper type inference is done on a simple language which is lambda calculus extended with let expressions and the fixpoint combinator. Lambda calculus in itself is Church-Turing complete and could thus represent these added constructs but they simplify ... (add stuff here)

%\begin{description}
%\item[The simple language] \hfill
%\begin{description}
%  \item[Variables] \hfill \\
%    A variable is an expression.\\
%    Ex. x is a valid expression.
%   \item[Abstraction] \hfill \\
%    An abstraction of a variable over some expression. (wording?)\\
%    Ex. (\textbackslash x . x) is a valid expression.
%   \item[Application] \hfill \\
%    An application of an expression to another expression is an expression.\\
%    Ex. (f x) is a valid expression.
%   \item[Extensions] \hfill
%\begin{description}
%    \item[Let] \hfill \\
%      A let expression, defining a variable within the scope\\
%      of an expression, is an expression.\\
%      Ex. (let x = n in (f x)) is a valid expression. 
%    \item[Fix] \hfill \\
%      The fixpoint combinator enables recursive expressions.\\
%      A fixpoint combinator y satisfies y f = f (y f).
%\end{description}
%\end{description}
%\end{description}

%\subsection{Type inference with Algorithm W}

%Where the original Algorithm W uses a top-down approach we have chosen to implement it using a bottom-up approach (sometimes called Algorithm M REF: generalizing hindley-milner type inference algorithms, Heeren,Hage,Swierstra ). The bottom-up approach generates constraints on the types in a first pass and then solves these constraints producing the most general type for each expression.

%\begin{description}
%  \item[Generating constraints by inference rules] \hfill \\
%A first pass generates constraints on the types by a set of inference rules (see appendix). \todo{FILL OUT}
%  \item[Solving constraints by solving rules] \hfill \\
%Secondly we solve the inferred types using the accumulated constraints to produce the most general type for each expression. \todo{FILL OUT}
%\end{description}
