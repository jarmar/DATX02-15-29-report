\section{Methods discussion}

This section discusses the methods used while developing the Hopper language and its compiler. A lack of initial structure would become apparent later in the project but the chosen path still proved to be productive. Going in to the project the group had limited knowledge of the problem area and of the capabilities of the group which made initial planning difficult.

\subsection{Agile development - sprint length}

Sprint lengths were initially short and had small incremental goals. This worked well for parts of the compiler where the structure was relatively flat and new content could be added without affecting old content to any greater extent. 

One notable exception was the type checker where implementing a small subset proved to be a big challenge. Longer sprints would probably have seen the same difficulties though since they were due to differences between compiler parts more than the sprint lengths.

\subsection{Lack of daily communication}

Not having continuous follow-ups might have prolonged the difficulties in getting the full pipeline working. The weekly meetings had the long term plans running but not many insights into the detailed problems discovered in each part. Workshops were held to emphasize group work and communication channels were set up to have group members help each other between meetings. This all proved very helpful but some problems were still discovered a bit later than they might have been with more frequent face to face meetings. In hindsight there could not have been much done about the number of meetings with the six group members having different schedules. Better communication through the supplied channels might have been a good middle ground.

\subsection{Lack of a project leader}

No one person had the responsibility to catch on to potential problems or coordinate development. Most sections of the compiler were worked on by only a couple of team members, making it difficult for others to make modifications or understand the code. This led to considerable latencies any time a change across several different modules was required. Had a project leader coordinated the development of new features across the pipeline, that slowdown might have been avoided.

Further, appointing a technical lead responsible for specifying the interfaces between components (i.e. the data types representing the program and the type signatures of exported functions) could have made it easier for members to use code they had not themselves written.

Sharing the responsibility as a group felt natural going in to the project and not knowing each other made choosing a leader difficult. Having the group leader responsibility rotate between group members might have been a solution. Another could have been to hold off on assigning a leader until the group got to know the problem, and each other, better.

\subsection{Lack of a hard specification}

Starting the project the group agreed on potential features that could be added to the language. A list of such features was compiled to use as a general direction in which to take development. 

The incremental development approach that then followed, beginning with a small subset of the language, quickly lost track of these initial goals. This meant that group members mostly made their own decisions about what steps to take in the development of their areas of responsibility. For the most part this worked fine but in some cases it led to too much freedom and decisions that should possibly have been made as a group were made by fewer members. In hindsight, a more formal specification agreed on by the group might have had group members working more together and towards a common goal.

\subsection{Revision control system}

The use of Git \cite{git} as our revision control system was successful. The ease of branching, working locally and merging was a good fit for the group dynamic employed. 

There were times during the project when the number of branches rose a bit high. With six group members there should often not be a need for eight or nine simultaneous versions of the code. Efforts were made to merge branches and keep the number low with one branch hosting the main development version and separate branches for new features being developed.

\subsection{Type checker branches}

The type checking took two different directions early on which led to two separate branches. They were in some ways similar in concept but different in their approach to the subject. This led to time lost both through other compiler phases waiting for a functioning type checker and through one of the branches in the end being discarded in favor of the other branch. 

The type checker development was in many ways not suited for the incremental growth that the project started with. Beginning from a smaller grammar and expanding it felt natural but there was no easy way of beginning with a small type checker. 

Since the type checking was also a heavy theoretical subject there were many sprint cycles before any useful code was added to the type checker in the compiler pipeline. To reduce the effect of this on the development of the rest of the compiler a "mock" type checker was implemented which assumes all programs are fully and correctly typed, and does nothing. This allowed developing the other parts of the compiler independent of the progress on the type checker.


\subsection{Responsibility rotation}

Beginning with the small subset of Hopper there was a division into groups which became static due to problems with the type checker.
The initial idea for the project was to have all group members' work on every part of the project. This would not only support the learning goals of the project but would also ensure that each member of the team wrote code in each of the modules. Rotations could have made it easier for team members to make their own modifications to any module when needed, thus avoiding large latencies and deadlocks caused by the need for alteration to some other compiler phase. 

