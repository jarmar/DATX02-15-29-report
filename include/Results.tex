\chapter{Results}

\todo{Assigned Johan L temporarily}


\todo{perspective: what we aimed for - what we achieved/didn't achieve, why in discussion}

\todo{Talk about the results, how well we think we fulfilled the initial task, and what we didnt fulfill}

\todo{what the compiler is capable of}
* Imports
* Exports
* Curried functions
* ADTs
* BIFs (which will give us send ect but not receive)

% Could be used as the pure part in an application. For example using Hopper to implement an difficult algorithm but using Erlang as the glue to the rest of the system. 

\todo{expressiveness of grammar}
% * Indent sensitive
% * Type signatures 
%   * Parameterized types
% * ADTs
% * Pattern matching
%   * Tuples
%   * Constructors
%   * Variables
%   * Primitives
%   * Wildcard/ignore
% * Case expressions
% * Lambda expressions
% * If expresssions
% * infix Operators
% * primitives
% * Tuples
% * Qualified functions and constructors

\todo{different output from compiler}
% * Debugging info: parse tree, ast, typed ast, core

\todo{STATE results objectively, leave what the results mean to discussion}

\todo{Results: state results objectively, Discussion: what do results mean, what could have been done different, what could be a continuation etc. Conclusion: did we answer the problem formulation? what is the answer?}

%From what I remember, the initial task was to create a Haskell like language and a compiler from said language to .beam, using Core Erlang. Regarding features, we never decided on what the language should be capable of doing by the end of the project. Instead we said that we would start with an extremely simple version of the language; parameterless functions returning constants. Then we would expand the language feature by feature and sort of see how far we could take it in the given time. I think that we can just briefly list the features that were implemented, and features that we had talked about but never got around to implement (type classes, receive clauses, do notation (i.e. sequencing), let expressions, where expressions are the ones I can think of, expand this list here if I missed something?). Then we can have a followup of this in the Conclusions chapter (go there to read what I mean) // Johan WS

% I've been staring at this for quite some time and I might have an idea of what should be done. Since Results should present the results objectively and not add any new information or have an opinion regarding the results I think the results will be somewhat short. But I think that might be ok. Our result is a "product" and what we can state as results are "these things are in and these things are not in" so more or less a list of features. This would work if we clearly connect it to the discussion where the actual analysis of the results will take place and there we can actually say whether we think the results are good or not etc. For the conclusion I think that that part also will be quite short, focusing on whether we have answered the problem and what that answer is (is Hopper a good idea?). I e-mailed Nick and asked if he thought this would work (the short results section), maybe we should add it as a question for Fackspr√•k 2 as well? / JL


The result of the project is the Hopper language and its compiler. Included in the language is...

\section{The Grammar}
The resulting grammar from the project is a clean basic functional programming language with indentation sensitive syntax featuring polymorphic \Acrshort{adt}s, pattern matching and lambdas.

Additional grammatical features % other word for feature
was planned and designed but not implemented. Most of these features was syntactic sugar  for lists and tuples but also syntax for simplifying repetive tasks like \texttt{IO} sequencing also known in Haskell as \texttt{do}-notation. 

%\subsection{Implemented}

% Basic functional programming language wiht ADTs, Pattern matching
% + lambdas, ADTs are polymorphic

%\subsection{Designed but not implemented}

% List sugar, do notation, receive, operator definition, 
% tuples, infix operator definition, type classes,
% receive syntax, modules (will we fix?)

\section{The Compiler}
% Would this list features that was planned but not implemented at all? Not for example syntax specific features but more like type classes and receive, features that impact the whole compiler?
\subsection{Implemented}
The compiler is capable of producing runnable Erlang Code on the same level as the expressiveness of the grammar. It can compile simple functions and \Acrshort{adt}'s, lambda expressions, control constructs like if and case expressions, pattern matching over arguments, and the use of tuples. The fact that the Hopper compiler generates BEAM modules also allows for a degree of interoperability; Hopper modules may be integrated with modules written in Erlang, and vice versa.

%Mention the compilers flags and their results

\subsection{Designed but not implemented}
Some features that were discussed and planned but not implemented in the compiler were a generic solution for accessing Erlangs built in functions (BIF's), receive clauses and sequencing. However, some of these features, like accessing BIF's and emulating the receive clauses, are already provided by the compiler in some sense, but the idea was to build wrapping solutions for them in order to make Hopper as user friendly as possible.