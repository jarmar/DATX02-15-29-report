
Ex 1:

import IO (unsafePerformIO)
import Monad (mapM)

parallel_map :: (a->b) -> [a] -> [b]
parallel_map f xs = unsafePerformIO $ -- discipline! no impurity!
	do s <- self
	   r <- make_ref
	   mapM (\(i,x) -> spawn (s ! ((i,r),f x))) 
		(zipWith [(i,r)| i <- [1..length xs]] --note not 1.. bc no laziness
			 xs)
	   mapM (\i -> unsafeReceive (i,r,res) -> res) [1..length xs]

--Implementation details:

--(!) :: Pid -> a -> IO ()
--receive can receive values of any type,
--which means (!) must send the type of a value in a tuple {TypeRep,Val}
--(so that you don't confuse e.g. Int and newtype Age = Age Int);
--receive must check the type rep at runtime, which adds a
--performance cost. unsafeReceive does not; it ignores the typerep
--(at your own risk!). Because refs in Erlang are only equal to themselves
--and a unique one is made every time with make_ref, the unsafeReceive in
--parallel_map is safe.

I wrote it like that because I assumed you'd implement typed channels with a separate
mailbox process you query (which would be expensive). However, it can be done with a ref: 
newtype ReceiveChan a = RChan Ref
newtype SendChan a = SChan Ref
newChan :: IO (ReceiveChan,SendChan)
sendChan :: SendChan a -> a -> IO ()
receiveChan is a syntactic form just like normal & unsafe receive
(receiveChan (chan :: ReceiveChan a) of
	(p1 :: a) -> (res1 :: b)
	(p2 :: a) -> (res2 :: b)) :: IO b 

Ex 3:

--type URL = String
import Networking (url_atom :: URL -> String -> IO Atom,URL)
{- url_atom url s = (do ip <- dnsLookup url
			return $ Atom ("\'"++s++"@"++show ip++"\'")
-} 

data SomeSuperComplexScriptTypeOrSomething = <Tons of constructors with all sorts of types>

chatProgram :: IO ()
chatProgram = 
     do s <- self
	pid <- spawn $ yourGui s --will send you instructions from user
	server <- url_atom "chatserver.com" "server"
	(tyChans1,tyChans2,tyChans3) <- liftM3 (,,) newChan newChan newChan
	atomToPid server ! (snd tyChans1,snd tyChans2 ...)
	< Get some chans from server too: good for speed, reasoning about code >
		--stuff from the gui:
	receive ('sendAMessage',msg) {-have atom literals for speed?-}
	        <send via some chan to server> msg
		('runAScript, s :: SomeSuperComplexScriptType)
		<send s via chan to server> --serialization for free!
		<receive result via chan from server>





