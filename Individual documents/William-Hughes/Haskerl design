
Haskerl Design
Adopt as much of Haskell as possible – all syntax: 
	do, let, where, case, if-then-else, M.name, infix operators, comments etc.
Expose as many Erlang BIFs as possible:
	(!) :: Pid -> a -> IO () {- This requires sending {TypeRepOfValue,Value} at runtime. 
I suggest making the class Typeable, which has the method typeOf :: a -> TypeRep be automatically inferred 
  for all types -}
	Borrow from Cloud Haskell: sendChan :: SendPort a -> a -> IO ()
 	(term_to_binary :: a -> ByteString,Prim.(==) :: a -> b -> Bool,term_to_string :: a  -> String)
	spawn :: IO a -> IO Pid, etc.
	(receive (a1 :: A1) -> b1;(a2 :: A2) -> b2) as syntactic sugar for:
		(receive {TypeRepOfA1,a1}->b1;
		               {TypeRepOfA2,a2} ->b2 end) at runtime

Ets stuff would probably be cool to have too.
Focus on efficient representation of values at runtime:
	Just x ==> {x},Nothing ==> {}; (35 :: Integer) ==> 35 %%An Erlang integer
	(35 :: Double) ==> 35.0; someIO ==> fun() -> someIO end;
Have function to_prettyErl :: a -> ErlangTerm that converts (Just x) to {just,x}; 
use this for debugging (makes data structure readable) and interfacing with erlang code.
data ErlangTerm = Tuple [ErlangTerm] | EDouble Double | EPid Pid | EAtom Atom … when calling Erlang code 
whose return values don’t all belong to one type (e.g whereis :: Atom -> (Pid | undefined)), 
you explicitly acknowledge that the return value doesn’t correspond to any Haskerl datatype by making it be of the 
general ErlangTerm datatype. 
You’d import whereis by doing something like this:
whereis :: String -> Maybe Pid
whereis s =   case (erlang{fun erlang:whereis/1} :: Atom -> ErlangTerm) (Atom s) of
		EPid p -> Just p
		EAtom (Atom “undefined”) -> Nothing


If at all possible, I think we should have typeclasses. I’d sorely miss (+),fromInteger,(>),(==),(>>=) and friends.
If we do, we also have the chance of undoing one of Haskell’s mistakes: the fact that the types (a1,a2,a3) and (a2,a3) 
have no relation with each other in the type system! If we had a ‘tuple-cons’ 
data a :&& b where (:&&) :: Tuple b => a -> b -> a :&& b, then we could define Eq, Ord etc. for tuples with any number 
of elements just by defining the class for () and a :&& b. Did you know that show (1,2,3 … 17) will result in an error? 
I believe OCaml does this with its (*) type operator.

Moonshots

This is stuff that doesn’t strictly belong to the copy Haskell/access Erlang via library plan. 
I’ve thought of implementing a (rather different) language with these features.
Generalized dotdot-notation: op x (op y .. optionalUpperbound):
	[a,b..c] desugars to (:) a ((:) b .. (:) []), fac n = 1 * .. n, 
sumOfSquares n = x*x + .. n*n
Nicer syntax tree literals than haskell’s [| expr |]: ‘3 + 5’, ‘c’ :: Char; ‘ c’ :: Tree
New syntax declarations: syntax [Either String (Parser Tree)] ([Tree] -> Tree) :: Decl or Tree
Example: syntax [“if”,parse_expr,”then”,parse_expr,”else”,parse_expr] (\t1 t2 t3 -> Apply ‘ifte’ t1 t2 t3) 
-–I left out Left/Right constructors for brevity; 
this requires that the first element of the list is a Left String, so you can recognize a new syntax is beginning. 
Syntax [“go_get”,parse_url] (\url -> unsafePerformIO (fetch url, compile it)	
“Context” declarations: why can’t the lambda syntax just be an operator (->), and we specify how the syntax trees 
passed to it be interpreted  (the “context” of its arguments, e.g.  pattern) 
(This is probably impractical, since it’s much harder without first class patterns)
	
