module MyModule (start) where 

-- Imports a HaskErl library
import Maybe 

-- Erlang Function Interface
efi io.write/1 :: String -> IO ()
efi erlang.list_to_atom/1 :: String -> Atom
efi erlang.spawn/3 :: Atom -> (a -> IO ()) -> a -> IO Pid 
efi erlang.send/2 :: Pid -> a -> IO () -- Or infix (!) ?
efi erlang.self/0 as getSelfPid :: IO Pid

-- Conflicting import with alias
efi lists.concat/1 :: [[a]] -> [a]
efi lists.concat/2 as append :: [a] -> [a] -> [a]

-- start/main
-- Reference a module name could be nicer. Especially the own one.
start = spawn (list_to_atom "mymodule") loop 3000

-- This is nice because a constructor matches a Erlang tuple with a tag
--   Add pid 1 2 â‡” {add, Pid, 1, 2} 
-- but it will allow same name constructors
data Message = Add Pid Int Int
             | Divide Pid Int Int
             | Answer Pid Int
             | DivisionByZero

-- Simple loop server. Does nothing exciting but shows receive
loop :: Int -> IO ()
loop n 
  | n < 0     = write "Timeout less than 0ms. Exiting."
  | otherwise = do 
    self <- getSelfPid
    receive 
      -- Messages must be same type!
      -- Other messages that don't belong to type will automatically be discarded.
      (Add pid a b) -> do 
        send pid (Answer self (a+b)) 
        loop (n+1000)

      -- With guard
      (Divide pid a b) | b /= 0 -> do
        send pid (Answer self (a `div` b))
        loop (n-1000)

      -- With typenotation to help typechecker
      -- This will only be needed on one clause
      (Divide pid _ _) :: Message -> do
        send pid DivisionByZero
        write "Got division by zero. Exiting."
    
    -- Timeout clause
    after n -> write "Got no messages in a while. Exiting."

